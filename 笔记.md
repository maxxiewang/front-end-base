基础题：
一、v-show 与 v-if 的区别？
二、为何 v-for 中要用 key?
三、Vue 生命周期（有父子组件的情况）
四、Vue 组件如何通讯？
五、描述组件渲染和更新的更程，体现深度与广度
六、双向数据绑定 v-model 的实现原理

进阶题：
一、

- v-show 与 v-if 的区别？

vshow 是 css 中 display:none，使用 v-if 会触发页面重绘，频繁切换的使用 v-show，性能稍好一些

- 为何 v-for 中要用 key?
  diff算法就是基于key来实现的。
  v-for 比 v-if 的优先级要高，但不能在一块使用

- Vue 生命周期（有父子组件的情况）
  created 、mounted、beforeDestoryed、Destoryed
  父组件 created 然后执行子组件流程，created,mounted, 最后父组件 mounted
  更新时也是 父组件 beforeUpdate，子组件 beforeUpdate，子组件 updated，父组件 updated

- Vue 组件如何通讯？

1.  props $emit
2.  $emit 自定义事件
3.  pubsub.js 做一个订阅发布
4.  Vuex

- 描述组件渲染和更新的更程，体现深度与广度。

- v-model 的实现原理？

Vue 的基本使用
v-html 会把里面包裹的覆盖掉，并且有 xss 风险。
watch 开启深度监听，监听引用类型，拿不到 oldValue
《观察》事件被绑定到了哪里
// 1. event 是原生的
// 2. 事件被挂载到当前元素
// 和 DOM 事件一样

带子组件的生命周期：
1、挂载 B+created B+mounted
2、更新 B+upeated
3、销毁 beforeDestory destoryed

自定义 v-model，这东西，:value 绑定个值，然后，在 script 里面，有一个 model 属性去声明。
this.$nextTick:
1、Vue是异步渲染框架，data改变之后，DOM不会立刻去渲染
2、$nextTick 会在 DOM 渲染之后去触发，去获取新的 DOM 节点
slot: 父组往子组件去插入一段内容。作用域插槽：子组件里面的值传递给外面，利用 v-slot 特性。
具名插槽: v-slot:header v-slog:footer 绑定了一大堆，能过

动态组件: <component :is="componentA"/>

异步组件：按需加载，异步加载大组件
在组件当中，以前引用都是 CustomVModel 这种，script 里面 import 进来，进接注册（同步加载）
components: {
// CustomVModel,observer
FormDemo: () => import('../BaseUse/FormDemo'),
},
mixin: 多个组件有相同的逻辑，利用 mixin 抽离出来，mixin 可以引用多个。mixin 遗留的问题由 Vue3 的 Composition API 解决这些问题。问题：变更来源不明确，不利用阅读。

Vue-router：路由配置（动态路由、懒加载）


### Vue原理
在Object.defineProperty这个API的实现在，有几个缺陷。
深度监听，需要递归到底，一次性计算量大
无法监听新增属性/删除属性（Vue.set Vue.delete）

V-Dom：
原来的DOM操作非常耗费性能，把更多的计算转到JS上来，因为JS执行速度更快。vdom用js模拟DOM结构，利用diff算法计算出最小的变更，操作DOM。
diff算法：
